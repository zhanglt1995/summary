# summary
# **个人总结**

## day01

类的定义和对象的创建及使用，对象创建时的内存模型，在加载类的时候会将类的成员方法的代码放在方法区中，当对象初始化的时候会在堆中申请一块位置，每个对象拥有独立的成员变量，但是在堆中，只会存储成员方法在方法区中的内存地址，当成员方法执行时，会在栈中申请一块内存给方法使用，调用完毕会弹栈

Java虚拟机 JVM

线程共享区域:方法区,堆,直接内存 ; 线程共享区域随虚拟机的启动/关闭而创建/销毁。 

线程私有区域:本地方法栈,虚拟机栈和程序计数器 ; 线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的 生/死对应)

垃圾回收方法：

标记清除 ：磁盘空间比较零散

复制

标记整理

分代收集：分为新生代和老年代，新生代要清除的内容很多，使用复制方法，因为需要复制的很少，新生代会有3块空间，一个Eden区，两个survivor区，一般会使用Eden区和一个survivor空间，当垃圾回收时，会将前两个区存活的对象复制到另一个survivor中

老年代使用标记复制算法



```java
学生登录系统：http://ntlias-stu.boxuegu.com/
```

## day02

- 重载： 重载发生在同一个类中，方法名相同，参数列表不同（参数的个数，类型），与返回值无关, 构造方法也有重载方法

- 重写：重写发生在父子类中，方法的名字，参数列表，返回值都相同，子类重写方法的权限修饰符要大于等于父类方法的权限修饰符，子类抛出的异常要小于等于父类的异常，重写的方法可以使用@Override标识

  - 注意：父类的私有成员方法不能被重写！父类和子类的静态方法一样也不是重写

- this的三种使用方式

  - this.成员变量，用于区分同名的成员变量和局部变量
  - this.成员方法，一般都可以省略this
  - this(),this(参数)，访问构造方法
    - 在空参构造方法中，使用this(参数)来访问有参的构造方法，注意，这行代码一定要放在空参构造方法的第一行，否则会出现编译报错
    - 在有参构造方法中，使用this()来访问空参构造方法，这行代码同样也需要在第一行

- super的使用

  - 访问父类成员变量:super.父类成员变量名  主要用来区别父子类同名的成员变量
  - 访问父类成员方法:super.父类成员方法名(实参)  主要用来调用父类的成员方法
  - 访问父类构造方法:
        空参: super();
        有参: super(实参);
    注意: 在子类构造方法中调用父类的构造方法,需要放在子类构造方法的第一行
  - super关键字的注意事项：
    - 1. super访问父类成员变量和成员方法: 优先去父类中找,如果有就直接使用,如果没有就去爷爷类中找,如果有,就用,依次类推...
      2. 子类的构造方法默认会调用父类的空参构造方法,如果父类中的没有空参构造方法,只定义了有参构造方法,会编译报错

- final关键字

  - final修饰类，被修饰的类不能被继承
  - final修饰方法，该方法不能被重写
  - final修饰变量，被修饰的变量会变成常量，只能被赋值一次
    - 如果是引用数据类型，则保存的地址不能变，该地址中对应的内容可以改变

- static关键字

  - static修饰成员变量，变成静态成员变量，静态成员变量被所有对象共享，就是说一个对象对该变量做了修改，其余的对象再次访问该变量时，也是都是修改后的值

  - static修饰成员方法，可以直接使用  类名.静态方法（参数）

    - 注意事项：

      1.静态方法中不能出现this关键字

      2.静态方法中不能直接访问非静态成员(非静态的成员变量和成员方法)

      3.静态方法中能直接访问静态成员(静态的成员变量和成员方法)

      4.非静态方法中可以直接访问一切成员(非静态和静态成员)

      5.子类中出现了和父类一模一样的方法静态方法,这不叫做方法重写,只是长得像方法重写

  - static修饰代码块，随着类的加载而执行,并且只执行一次，执行顺序要在构造方法之前

## day03

#### 面向对象的三大特点：

- 封装

  将某些东西私有化，不直接给外部访问，而是封装起来，保证数据的安全性

- 继承

  想要别人的代码，就要使用extends关键字继承其他类，从而获得其他的成员变量和成员方法，从而减少代码的冗余，提高代码的可复用性

- 多态

  多态编译的时候看等号左边，运行时，非静态方法看右边，其余的还是看左边

  使用场景：方法形参

  好处：提高代码的可扩展性

  弊端：只能访问父类的共有的方法，不能调用子类特有的方法（使用引用数据类型的向下转换来解决这个问题，但是父类类型的变量一定是指向该子类的对象）

#### 接口与抽象类的异同：

- 接口中有成员变量和抽象方法，java8后可以有默认方法（必须用default修饰）和静态方法，java9后可以有私有方法
- 抽象类中可以有非抽象方法，可以有变量，接口只能有常量
- 接口权限修饰符除了私有方法只能是public，接口的静态方法只能供接口调用。
- 抽象类体现的是模板设计的思想，接口更像是定义一个规则标准

数据类型转换：

- 向上转型： 子类 ---->父类  这个过程相当于自动转型

- 向下转型 ：父类 -----> 子类     子类  =  （子类）父类类型的变量（这个变量指向子类对象）  这个相当于强制转换

  作用就是解决多态的弊端的

  注意：向下转型可能会发生数据类型转换异常，使用instanceof进行判断是否属于那个类型，避免异常情况

**引用数据类型传值是传递的地址值**，一个地方做了修改，其他地方也会改变



## day04

#### String，StringBulider，StringBufer 三者的区别

- String：被final修饰，是不可变的，但是可以被共享，一般用于URL地址传值等不变字符串的情况下使用
- StringBulider：是可变的，可以在后面追加字符串，线程是不安全的
- StringBufer ：是可变的，可以追加字符串，线程是安全的





```java

```



## day05

#### 权限修饰符

|                      | public | protected | 默认（缺省） | private |
| -------------------- | :----: | :-------: | :----------: | :-----: |
| 同一类中             |   √    |     √     |      √       |    √    |
| 同包（子类与无关类） |   √    |     √     |      √       |    ×    |
| 不同包子类           |   √    |     √     |      ×       |    ×    |
| 不同包中的无关类     |   √    |     ×     |      ×       |    ×    |

访问权限大小 public  >  protected  >  默认（空）  >  private

#### 代码块，构造方法执行顺序

静态代码块，只执行一次，最先执行

构造代码块，每次创建对象都会执行一次，在构造方法前执行

局部代码块，调用方法，执行到该位置的时候才会执行，可以提前释放内存（一般很少使用）

执行顺序：父类静态代码块 -->  子类静态代码块 ---> 父类构造代码块 ---> 父类构造方法 ---> 子类构造代码块 ---> 子类构造方法

#### 基本类型和包装类型

| 基本数据类型 | 包装类型  |
| ------------ | --------- |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |
| char         | Character |
| boolean      | Boolean   |

包装类型和基本数据类型之间是自动装箱和自动拆箱的

#### BigDecimal的注意事项

1. 如果使用new BigDecimal(double d)的构造方法创建对象的话,同样会发生精度损失的情况
2. 如果不能整除,要直接使用bd1.divide(bd2)会抛异常, 要使用重载方法,指定小数点的精度和取值类型bd1.divide(bd2,2, RoundingMode.HALF_UP)  



## day06

这是综合案例的一天,所以没有新的知识点, 但是项目的编程注意要进行分包，以及要注意方法的抽取，不要把所有功能都写在一起



## day07

#### 泛型

泛型是一种未知的类型，在使用的时候才知道具体类型

泛型可以定义在类中，方法中，接口中

泛型中没有多态

泛型中的上限：格式 <? extends XXX> 表示传入的内容可以是XXX及其子类，不能超过XXX

下限：格式<? super XXX>  表示传入的内容可以是XXX及其父类类型，不能小于XXX

#### 集合

单列集合

父接口collection

- List(接口)
  - ArrayList(实现类)
  - LinkedArrayList
- Set(接口)
  - HashSet
  - LinkedHashSet
  - TreeSet



#### 集合的总结

List集合： 元素是有序的,可以重复的，有索引，可以使用普通的for循环遍历

- ArrayList : 

  1. 线程不安全 , 
  2. 底层用数组进行实现的，查询速度快，增删速度慢（在中间插入元素是，总是会将数组进行复制，移动）
  3. 排列有序，元素可以重复
  4. 当容量不够时，扩容后是当前容量 * 1.5 +1

- Vector :

  1. 线程安全，效率低
  2. 排列有序，元素可以重复
  3. 底层使用数组，查询速度快，增删速度慢
  4. 扩容机制，每次增加到原来的2倍

- LinkedList  : 

  1. 线程不安全 

  2. 底层适用链表实现，查询速度慢，增删速度快

  3. 排列有序，元素可以重复

     

Set集合  : 不可重复，没有索引，（不能使用普通的for循环遍历）

- HashSet
  1. 排列无序，元素不可以重复
  2. 底层使用hash表实现
  3. 存取速度快，内部是HashMap
- LinkedHashSet ：
  1. 采用hash表存储，并用双向链表记录插入顺序，是有序的
  2. 内部是LinkedHashMap
- TreeSet
  1. 排列无序，元素不可重复
  2. 底层使用二叉树实现
  3. 排序存储（Integer和String可以直接进行默认排序，自定义的对象必须实现Comparable接口，并且重写compareTo方法才可以正常排序）
  4. 内部是TreeMap中的SortedSet

Map集合

- HashMap：
  1. 线程不安全，
  2. 键值不可以重复，存储的值可以重复
  3. 底层使用hash表， 数组+链表+红黑 树
  4. 键值可以为null，但是只能有一个，值中可以使null
  5. 扩容机制，当前容量的值如果超过容量*负载因子(0.75)，就会扩容到原来的2倍
- HashTable：( 不建议在新代码中使用，不需要线程安全 的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。)
  1. 线程安全
  2. 键值不可以重复，存储的值可以重复
  3. 底层使用hash表
  4. 键和值都不能是null
- TreeMap ：(在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常)
  1. 键不可以重复，值可以重复
  2. 底层使用二叉树

#### 迭代器

迭代器用来遍历集合中的元素，因为set集合中没有索引，所以要用迭代器来遍历集合中的元素

使用迭代器时候要先获取迭代器对象，集合对象.iterator()

遍历的时候使用while循环，每次都使用hasNext方法进行查询是否有要迭代的元素 ，如果有，则循环使用用next方法将值取出，如果没有要迭代的元素，就结束循环

**注意事项：**

1. 当迭代器中元素已经取出完后，再次取值，就会报异常，如果还想取值，就要重新创建一个迭代器对象
2. 在迭代器中不能对集合进行新增和修改，不然会报并发修改异常，解决，使用迭代器的方法remove

#### 数据结构

栈：特点：先进后出，可以想象弹夹的子弹

队列：特点：先进先出。可以想象排队打饭

数组：特点：有索引，查询快，增删慢，每次数组元素新增或者删除时都会重新创建一个新的数组

链表：特点：查询慢，增删快，链表会有数据域和指针域，每次查询都要重开头查找，但是增删数据时，只需要修改指针域中的数据即可

树型结构，二叉树，提高查询效率的





## day08

#### Collections工具类：

使用sort方法，进行默认排序的时候，元素类型所属的类必须要实现Comparable接口，重写CompareTo方法

#### HashSet中保证元素唯一

1. 当集合存储元素的时候，首先会调用对象的hashCode方法，获取到相应的哈希值

2. 去看该哈希值位置上有没有其他元素

3. 如果没有其他元素，则直接存储

4. 如果这个哈希值上还有其他元素，就产生了哈希冲突

5. 如果产生了哈希冲突，就要使用equals方法来与该哈希值上的其他元素一一比较

   如果有相同的，则不存储

   如果都不相同，则存储

如果是自定义类型的，要重新hashCode和equals方法，

#### 重写equals方法和hashCode方法

如果在hash表中想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方 法。

如果hashCode()方法不重新，默认hashCode方法是根据地址值来计算hash值的，多以每个对象都有不同的hash值，这个时候不会存在hash冲突，元素会直接存储

一个hashCode位置上可以存放多个元素，hashCode值相等，产生hash冲突后，会调用equals方法

如果equals方法不重新，默认比较的是地址值，属性相同的两个对象比较后也是不相等的，所以也会存储，只有也重新了equals方法，才能在hash表中认为是相同的



## day09

冒泡、选择排序算法，二分查询算法

#### throw和throws

位置不同

1. throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的 是异常对象。  

功能不同

2. throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方 式；throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并 将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语 句，因为执行不到。  
3. throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常， 执行throw则一定抛出了某种异常对象。 
4. 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异 常，真正的处理异常由函数的上层调用处理

throw产生异常，并将产生的异常对象抛出同时结束当前方法的执行，一般使用的位置是方法内

throws是声明处理异常，定义在方法声明后面，会将问题声明出来，自己不会处理，交给调用者处理

try... catch ...finally

即使是try或者是catch里面有return语句，finally代码块中的内容也会执行

#### 异常和错误的体系：

Throwable父类

下面有Error(错误) 和Exception(异常)两个子类

Error一般包括内存溢出和系统崩溃两种

Exception分为两个大类，

1. 编译期异常，这个必须处理，凡是不是RuntimeException及其子类的异常

2. 运行时异常，可处理可不处理，一般不处理，凡是RuntimeException及其子类的异常

   常见的运行时异常：数组下标越界异常，空指针异常，类型转换异常

#### 实现接口创建多线程对象比基础Thread类的优势

1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。

#### Java多线程执行原理

Java线程的调度是抢占式的

每个线程都有一个独立的栈内存空间

一个Java程序至少有两个线程，一个主线程，调用main方法；一条垃圾回收线程

线程的run方法执行完毕，说明线程的任务执行完毕，这个时候线程就会被回收



## day10

多线程

synchronized

Lock锁

volatile

线程池

```java

```


